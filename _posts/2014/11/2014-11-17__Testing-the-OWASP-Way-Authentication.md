---
layout: default
author: Chris Cornutt
email: ccornutt@phpdeveloper.org
title: Testing the OWASP Way - Authentication
tags: owasp,testing,guide,part5,series
summary:
---

Testing the OWASP Way - Authentication
--------------

{{ byline }}

##### IV. Authentication

Now we get into something a bit more complex - authentication. The previous section shared some testing advice for the general identity management handling of the application. Things like username enumeration or using a role matrix fit with just about any application out there. When you start to look at how it performs authorization, you start getting more into the "guts" of the system. It becomes more about *how* things are implemented and not just *what* is implemented.

There's a few of the points in this section that deal with weaknesses common to authentication handling, the first of which is sending sensitive information - in this case credentials - over an open or unencrypted channel. Think about an application that's largely driven by Javascript. This application has to communicate with an API backend to get information to share with the user. Obviously we want a way to identify the user that's making the request so we have them log into the system. The backend now knows who they are, but what about the frontend? I've seen some applications that take some kind of identifier, either something derived from the username/password or some kind of token and use that in their requests back and forth with the server. The worst part of it is, they do this over a normal `HTTP` request in plain view of anyone that happens to be sniffing around on the line between them and the server. The same thing applies for user login or registration handling. If the user submits their information via a normal form but `POST`s it to a `HTTP` page, the same kind of information exposure is possible. A simple fix for this one? Use `HTTPS`.

There's also some other "weakness" items that talk about having a poor "lock out" mechanism, poor password policy and bad password reset or security question/answer handling processes. Lets look at these one at a time and talk about the problems that can come up with each and how to effectively test them. First up, we'll look at the "lock out" handling. This is something that I've seen several sites, even major names, forget to add into their process. They want to give the users as many opportunities as possible to access their account and don't lock them out after a certain number of failed attempts. While this may make sense to someone on the business side not wanting to prevent users from logging in and ordering all sorts of goodies, it's terrible from a security aspect. Imagine what this would allow for someone trying to brute force the password on someone's account. If you're not doing any kind of request throttling or locking of the account after a certain number of failures, you're doing it wrong.

Some systems will just lock the user out for a certain amount of time, say fifteen minutes, and then allow them to try their login again. Hopefully the user remembers their credential this time and is able to access the system. If not, they'll have to go through the whole process all over again...unless they reset their password. This brings us to one of the other weaknesses: bad password reset handling. I've already mentioned the problems that can come up with the messaging from password resets, but there's also two major issues that are pretty common and can cause problems. The first issue is the new password being sent in plain-text in an email. There's *lots* if services out there that do this and, unfortunately, it's one of the least secure messaging methods that could be used for something as sensitive as a password. A *much* better option is to send the user an address with a one-time hash appended to it they can click and be able to reset their password from there.

The second all too common issue is that an application, upon the user resetting their password, logs them in immediately. While this may seem like a nice and user-friendly thing to do, you should always force the user to log in with the newly updated password first. This way you can verify they are who they are supposed to be and not have to worry about adding an exception to your authentication process that could potentially be used as a bypass if not protected correctly.

In addition to password reset functionality on the outside, ensure that you're requiring the user to enter their old password right along side the new password if they're changing it themselves. If an attacker somehow found a hole in your authentication system somewhere and was able to access a user's account management system, not having this check would allow them to change the password to whatever they want, all without the user's knowledge. They'd only find out when they came to log in next time (and with "remember me" functionality, an actual login may be a far time off).

The next "weakness" item is something that's always a point of contention among the secure development community: password policies. There's those out there that say that password policies shouldn't exist and it doesn't matter what kind of password the user picks, it's all about the storage of the password. After all, if the storage mechanism is strong enough, you don't have to worry about it being exposed, right? Wrong...well, partly wrong. The storage mechanism *is* important, but so is encouraging users to come up with stronger passwords. This is the whole reason for password policies. If you're storing the passwords the correct way, it won't matter what the actual password string is. It may be stored as a `bcrypt` hash or even an encrypted value, but if a user is allowed to pick the password "12345" you're sunk before you've even left the dock.

Password policies, while annoying (and overly specific at times) are more there to protect the business. People are terrible at coming up with passwords. They use things like their dog's name or their birthday or some other piece of public information that can be easily guessed, compromising the user's account. These policies requiring special characters, at least one number, seven capital letters, etc. help add to the overall complexity of the resulting password hash and make it more difficult for an attacker to crack were they able to get a full dump of the password information. The more *entropy* the password has, the harder it is to guess. Things like special characters, a wider character set and even just adding numbers can increase the time it takes to crack a password by a good bit. Also consider the content of the password - don't let the user include part (or all) of their username or email address in it if at all possible.

A good password policy also includes definitions on the time around required password changes, how often a user can reset their password and how long it is between the time they can use the same password. This last one is a bit more difficult as you have to store the information for the last X number of passwords to compare against. There's more clever ways to do this, but you still have to keep that information handy. As far as the time between resets...even the strongest password policy can't make perfect passwords. If an attacker is able to compromise even one hash in a decent amount of time, they'll be given clues as to how the passwords are stored. However, if a requirement is introduces that makes the user change their password often (even just 90 days can help), the information the attack has been working so hard on may be out of date before he can even get a chance to try it out. Couple this with the "can't use the same password in X amount of times" and you have a pretty strong system that can withstand an attack much better than just a simple system would.

While I'm on the topic of passwords, here's one that's easy to forget, especially if you're using a more "off the shelf" kind of software. With most pre-packaged applications, there's usually something that comes with it to make getting started easier: a default account. With this default account will come default credentials. I've seen some applications that do things a bit better and provide a password for the account. Not a strong one, mind you, but it's a password. Then there are the ones who chose poorly and decided that a default user doesn't really need a password and it's okay to leave it blank. This makes the setup process even easier, right? Well, what happens once someone typically installs and configures their software with this default account? More often than not, it's completely forgotten about. They may create an administrator account for themselves and only log in with that in the future, but that default account is still there, waiting to be used and abused. There's two ways to handle this problem: either remove the account completely (some systems won't allow this) or disable it so it can no longer be accessed. Hopefully this can be done through the user interface, but it may require a little hacking around on your part if not. Oh, and a word of advice to those vendors out there that think "no one should be able to disable the default account" - *you're wrong*.

Finally in the "weakness" area we'll look at the issues with security questions and answers. These "secret" questions are usually made up of overly generic choices, most of which could be found with a quick Google search or two. It's even worse if the user is heavily involved in social media and shares a bit too much about themselves. Think about the questions you've set up in the past...they ask about things like first car, favorite color or even mother's maiden name. These kinds of things can be super simple to find, making the security value of these questions quite a bit less. At this point they're just there to make sure the user *feels* more secure and are not actually more secure. Another issue with these questions is the number of options and the number of times you're allowed to guess at the answers. If there's only three questions to pick from, that significantly reduces the protection level they can provide. The same thing goes for the number of times you can guess at them. Even if you have five different security questions on your account, if you're allowing your users to guess until they get it right, you're adding a lot of risk to the authentication process. Think about hooking this into the "lock out" process I talked about earlier and doing something similar if they guess wrong too many times.